Event_Base::Event_Base()
{
	this->Type = Event_Types::TYPE_UNKNOWN;
	this->Code = 0;

	this->Thread_For = THREAD_ID_NONE;
	this->Thread_Created_By = E_Threads::Get_Thread();
}

Event_Base::Event_Base(u_char nType, u_short ID)
{
	this->Type = nType;
	this->Code = ID;									

	this->Thread_For = Events::Event_To_Thread( ID );
	this->Thread_Created_By = E_Threads::Get_Thread();
}

std::string Event_Base::To_String()
{
	char ID[3];

#ifdef _WIN32
	sprintf_s( ID, "%d", this->Code );
#else
	snprintf(ID, 3, "%d", this->Code );
#endif

	std::string Ret="Base Event - "+std::string(ID)+", ";
	switch(this->Code)
	{
	case 0:Ret+="Unknown";break;
//	case EVENT_EXIT:Ret+="Exit";break;
	default:Ret+="N/A";break;
	}
	return Ret;
}
/*
std::string Event_Default::To_String()
{				  		   
	char ID[4];memset(ID,0,4);itoa(this->E_Code,ID,10);
	char Arg[12];memset(Arg,0,12);sprintf(Arg,"%u",this->Argument);
	std::string Ret="Default Event - "+std::string(ID)+", "+std::string(Arg)+", ";
	switch(this->Argument)
	{
	//case EVENT_UNKNOWN:Ret+="Unknown";break;
	//case EVENT_EXIT:Ret+="Exit";break;
	default:Ret+="N/A";break;
	}
	return Ret;
}
			   */

#ifdef _WIN32
Event_Win32::Event_Win32()
{					 
	this->m_Msg = 0;
	this->m_wParam = 0;
	this->m_lParam = 0;
}

Event_Win32::Event_Win32(uint Msg, WPARAM wParam, LPARAM lParam)
{
	this->m_Msg = Msg;
	this->m_wParam = wParam;
	this->m_lParam = lParam;
}

//#include "WM_Strings.h"
std::string Event_Win32::To_String()
{				    		   
	char ID[4];memset(ID,0,4);itoa(this->Code,ID,10);
	char Arg[12];memset(Arg,0,12);sprintf(Arg,"%u",this->m_Msg);
	std::string Ret="Win32 Event - "+std::string(ID)+", "+std::string(Arg)+", ";
	memset(Arg,0,12);sprintf(Arg,"%u",this->m_wParam);Ret+=std::string(Arg)+", ";
	memset(Arg,0,12);sprintf(Arg,"%u",this->m_lParam);Ret+=std::string(Arg)+", ";

	switch(this->m_Msg)
	{
	case 0:Ret+="Unknown";break;
	//case EVENT_EXIT:Ret+="Exit";break;
	default:Ret+="N/A";break;
	}
	return Ret;
}

#endif




#include "Engine.hpp"



Event_Sub_Manager::Event_Sub_Manager()
{
	this->Processer = NULL;
}
 
Event_Sub_Manager::~Event_Sub_Manager()
{			
	this->Cleanup();
}

void Event_Sub_Manager::Cleanup()
{
	this->m_Mutex.Wait_For_Lock( );// __FUNCTION__ );
	this->m_Mutex.Lock();

	while( this->Event_List.size() > 0 )
		this->Pop_Event();

	this->m_Mutex.Unlock();
}
											 
void Event_Sub_Manager::Update()
{
	if( this->Processer == NULL )
		return;

	while( this->Event_List.size() > 0 )
	{
		this->Processer( this->Event_List.front() );
		this->Pop_Event();
	}
}

void Event_Sub_Manager::Add_Event( Event_Base* Event )
{
	this->m_Mutex.Wait_For_Lock( );// __FUNCTION__ );
	this->m_Mutex.Lock();

	this->Event_List.push( Event );	  

	this->m_Mutex.Unlock();

#ifdef _TEST
	Engine.Mem_Add( Event, "event" );
#endif
	//Engine.Application.Event_Log.Write_Log("Event Added: "+Event->To_String()); 
}

void Event_Sub_Manager::Pop_Event()
{
	if( this->Event_List.size() == 0 )
		return;		

	//Engine.Application.Event_Log.Write_Log("Event Removed: "+this->Event_List.front()->To_String() + "...");	   
	this->m_Mutex.Wait_For_Lock( ); // __FUNCTION__ );
	this->m_Mutex.Lock();
#ifdef _TEST
	Engine.Mem_Remove( this->Event_List.front() );
#endif
	delete this->Event_List.front();
	this->Event_List.pop();																				   

	//Engine.Application.Event_Log.Write("Success");	   

	this->m_Mutex.Unlock();
}








		   


E_Threads::Thread_ID_Type Event_To_Thread_List[ Events::EVENT_LAST_EVENT ];
void Set_Event_To_Thread_List();


Event_Manager::Event_Manager()
{
	// set event list
	Set_Event_To_Thread_List();			  
}

Event_Manager::~Event_Manager()
{
	this->Cleanup();
} 

void Event_Manager::Cleanup()
{
	this->Logic_Thread.Cleanup();
	this->Draw_Thread.Cleanup();
	this->Engine_Thread.Cleanup();
}

void Event_Manager::Add_Event( Event_Base* Event, std::string From )
{
	Event->Thread_Created_By_Str = From;
#ifdef _TEST
	if( Events::Event_To_Thread( Event->Code ) == Engine.Thread_Engine )
		this->Engine_Thread.Add_Event( Event );

	else if( Events::Event_To_Thread( Event->Code ) == Engine.Thread_Logic.t_ID )
		this->Logic_Thread.Add_Event( Event );

	else if( Events::Event_To_Thread( Event->Code ) == Engine.Thread_Draw.t_ID )
		this->Draw_Thread.Add_Event( Event );
#endif
}

E_Threads::Thread_ID_Type Events::Event_To_Thread( ushort ID )
{
	if( ID < Events::EVENT_LAST_EVENT )
		return Event_To_Thread_List[ ID ];
	else 
		return THREAD_ID_NONE;
}

using namespace Events;
#define THREAD_ENGINE Engine.Thread_Engine
#define THREAD_LOGIC Engine.Thread_Logic.t_ID
#define THREAD_DRAW Engine.Thread_Draw.t_ID

void Set_Event_To_Thread_List()
{
	memset( Event_To_Thread_List, 0, EVENT_LAST_EVENT );
		
	// OS EVENTS
#ifdef _TEST
	Event_To_Thread_List[ EVENT_WIN32 ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_LINUX ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_MAC ] = THREAD_ENGINE;

	// APP EVENTS	
	Event_To_Thread_List[ EVENT_WIN_RESIZE ] = THREAD_DRAW;
	Event_To_Thread_List[ EVENT_WIN_MOVE ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_WIN_ACTIVE ] = THREAD_ENGINE;

	// GAME EVENTS
	Event_To_Thread_List[ EVENT_PAUSE ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_RESUME ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_ENTER ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_LEAVE ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_BULLET ] = THREAD_LOGIC;
	Event_To_Thread_List[ EVENT_G_LOAD ] = THREAD_LOGIC;
	Event_To_Thread_List[ EVENT_G_SAVE ] = THREAD_LOGIC;
	Event_To_Thread_List[ EVENT_G_EXT ] = THREAD_LOGIC; // extra game event

	// MENU EVENTS																					
	Event_To_Thread_List[ EVENT_M_LOAD ] = THREAD_ENGINE; 
	Event_To_Thread_List[ EVENT_M_CLEANUP ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_BUTTON_DOWN ] = THREAD_ENGINE;

	// INPUT EVENTS	
	Event_To_Thread_List[ EVENT_KEYDOWN ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_KEYUP ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_MOUSE ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_GAMEPAD ] = THREAD_ENGINE;

	// BASS EVENTS											  
	Event_To_Thread_List[ EVENT_PLAY_SAMPLE ] = THREAD_ENGINE;
	Event_To_Thread_List[ EVENT_PLAY_STREAM ] = THREAD_ENGINE;

	// ENGINE EVENTS																					
	Event_To_Thread_List[ EVENT_EXIT ] = THREAD_ENGINE;
		
	//Event_To_Thread_List[ EVENT_THREAD_MAIN ] = ; // pause ] = ; resume ] = ; or inverse
	//Event_To_Thread_List[ EVENT_THREAD_DRAW ] = ;
	//Event_To_Thread_List[ EVENT_THREAD_LOGIC ] = ;
		
	Event_To_Thread_List[ EVENT_COMMAND ] = THREAD_ENGINE;

	Event_To_Thread_List[ EVENT_ERROR ] = THREAD_ENGINE;
#endif
}
